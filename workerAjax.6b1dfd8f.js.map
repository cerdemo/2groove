{"mappings":"ACAA,uCAAuC;AAEvC,KAAK,gBAAgB,CAAC,UAAW,SAAS,CAAK,EAC3C,IAAM,EAAO,EAAM,IAAI,AAEN,CAAA,cAAb,EAAK,GAAG,EACR,AAKR,iIAAiI;AACjI,oCAAoC;AAEpC,mEAAmE;AACnE,oDAAoD;AAEpD,wBAAwB;AACxB,0BAA0B;AAC1B,qBAAqB;AACrB,iDAAiD;AACjD,aAAa;AACb,iCAAiC;AACjC,4BAA4B;AAC5B,wBAAwB;AACxB,sCAAsC;AACtC,oCAAoC;AACpC,iDAAiD;AACjD,aAAa;AACb,SAAS;AAET,+BAA+B;AAC/B,gDAAgD;AAChD,sBAAsB;AACtB,uDAAuD;AACvD,iEAAiE;AACjE,kEAAkE;AAClE,SAAS;AACT,wBAAwB;AACxB,0CAA0C;AAC1C,2DAA2D;AAC3D,UAAU;AACV,IAAI;AAGJ,SAA2B,CAAK,CAAE,CAAG,CAAE,CAAgB,CAAE,CAAY,CAAE,CAAe,CAAE,CAAM,CAAE,CAAS,CAAE,CAAgB,EACvH,GAAI,CAAC,EAAiB,OAEtB,IAAM,EAAW,CAAC,OAAO,EAAE,EAAO,CAAC,EAAE,EAAU,WAAW,CAAC,CAC3D,QAAQ,GAAG,CAAC,sBAAuB,GAEnC,IAAM,EAAU,CACZ,OAAQ,OACR,QAAS,CACL,eAAgB,kBACpB,EACA,KAAM,KAAK,SAAS,CAAC,CACjB,MAAO,EACP,IAAK,EACL,KAAM,EACN,OAAQ,EACR,iBAAkB,CACtB,EACJ,EAEA,MAAM,EAAU,GACf,IAAI,CAAC,AAAA,GAAY,EAAS,IAAI,GAAK,wBAAwB;AAC5D,6IAA6I;AAC7I,yFAAyF;CACxF,IAAI,CAAC,AAAA,IACF,GAAI,EAAK,OAAO,CAAE,CACd,QAAQ,GAAG,CAAC,+BACZ,uFAAsF;AACtF,IAAM,EAAgB,KAAK,EAAK,IAAI,EAC9B,EAAW,IAAI,WAAW,EAAc,MAAM,EAAE,GAAG,CAAC,CAAC,EAAG,IAAM,EAAc,UAAU,CAAC,IAE7F,QAAQ,GAAG,CAAC,6BAA8B,EAAS,MAAM,EACzD,KAAK,WAAW,CAAC,CAAC,KAAM,iBAAkB,KAAM,CAAQ,EAC5D,MACI,QAAQ,IAAI,CAAC,EAAK,OAAO,EACzB,KAAK,WAAW,CAAC,CAAC,KAAM,QAAS,MAAO,AAAI,MAAM,EAAK,OAAO,CAAC,EAEvE,GACC,KAAK,CAAC,AAAA,IACH,QAAQ,KAAK,CAAC,SAAU,GACxB,KAAK,WAAW,CAAC,CAAC,KAAM,QAAS,MAAO,CAAK,EACjD,EACJ,EAjF0B,EAAK,KAAK,CAAE,EAAK,GAAG,CAAE,EAAK,gBAAgB,CAAE,EAAK,YAAY,CAAE,EAAK,eAAe,CAAE,EAAK,MAAM,CAAE,EAAK,SAAS,CAAE,EAAK,gBAAgB,CAElK,E,iE","sources":["<anon>","src/js/workers/workerAjax.js"],"sourcesContent":["(() => {\nvar $027baa645b81ae5d$exports = {};\n// worker for client-side ajax requests\nself.addEventListener(\"message\", function(event) {\n    const data = event.data;\n    if (data.cmd === \"sendArray\") $027baa645b81ae5d$var$sendArrayToServer(data.array, data.bpm, data.temperatureValue, data.hitTolerance, data.isHttpConnected, data.httpIp, data.portInput, data.samplingStrategy);\n});\n// function sendArrayToServer(array, bpm, temperatureValue, hitTolerance, isHttpConnected, httpIp, portInput, samplingStrategy) {\n//     if (!isHttpConnected) return;\n//     const data_url = `http://${httpIp}:${portInput}/send_array`;\n//     console.log(\"Sending request to:\", data_url);\n//     const payload = {\n//         method: 'POST',\n//         headers: {\n//             'Content-Type': 'application/json'\n//         },\n//         body: JSON.stringify({\n//             array: array,\n//             bpm: bpm,\n//             temp: temperatureValue,\n//             thresh: hitTolerance,\n//             samplingStrategy: samplingStrategy\n//         })\n//     };\n//     fetch(data_url, payload)\n//     .then(response => response.arrayBuffer())\n//     .then(data => {\n//         console.log(\"Processing tapped rhythms...\");\n//         // send a message back to the main thread if necessary\n//         self.postMessage({type: 'arrayProcessed', data: data});\n//     })\n//     .catch(error => {\n//         console.error(\"Error:\", error);\n//         self.postMessage({type: 'error', error: error});\n//     });\n// }\nfunction $027baa645b81ae5d$var$sendArrayToServer(array, bpm, temperatureValue, hitTolerance, isHttpConnected, httpIp, portInput, samplingStrategy) {\n    if (!isHttpConnected) return;\n    const data_url = `http://${httpIp}:${portInput}/send_array`;\n    console.log(\"Sending request to:\", data_url);\n    const payload = {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n            array: array,\n            bpm: bpm,\n            temp: temperatureValue,\n            thresh: hitTolerance,\n            samplingStrategy: samplingStrategy\n        })\n    };\n    fetch(data_url, payload).then((response)=>response.json()) // Process as JSON first\n    // checking the success field of the response, and if it's true, you're converting the data field (base64 encoded string of the MIDI binary) \n    // back to a byte array, and then you're posting this byte array back to the main thread:\n    .then((data)=>{\n        if (data.success) {\n            console.log(\"Processing tapped rhythms...\");\n            // const midiData = new Uint8Array(data.data);  // Convert base64 string to byte array\n            const base64decoded = atob(data.data);\n            const midiData = new Uint8Array(base64decoded.length).map((_, i)=>base64decoded.charCodeAt(i));\n            console.log(\"Received MIDI data length:\", midiData.length);\n            self.postMessage({\n                type: \"arrayProcessed\",\n                data: midiData\n            });\n        } else {\n            console.warn(data.message);\n            self.postMessage({\n                type: \"error\",\n                error: new Error(data.message)\n            });\n        }\n    }).catch((error)=>{\n        console.error(\"Error:\", error);\n        self.postMessage({\n            type: \"error\",\n            error: error\n        });\n    });\n}\n\n})();\n//# sourceMappingURL=workerAjax.6b1dfd8f.js.map\n","// worker for client-side ajax requests\n\nself.addEventListener('message', function(event) {\n    const data = event.data;\n\n    if (data.cmd === 'sendArray') {\n        sendArrayToServer(data.array, data.bpm, data.temperatureValue, data.hitTolerance, data.isHttpConnected, data.httpIp, data.portInput, data.samplingStrategy);\n    }\n});\n\n\n// function sendArrayToServer(array, bpm, temperatureValue, hitTolerance, isHttpConnected, httpIp, portInput, samplingStrategy) {\n//     if (!isHttpConnected) return;\n\n//     const data_url = `http://${httpIp}:${portInput}/send_array`;\n//     console.log(\"Sending request to:\", data_url);\n\n//     const payload = {\n//         method: 'POST',\n//         headers: {\n//             'Content-Type': 'application/json'\n//         },\n//         body: JSON.stringify({\n//             array: array,\n//             bpm: bpm,\n//             temp: temperatureValue,\n//             thresh: hitTolerance,\n//             samplingStrategy: samplingStrategy\n//         })\n//     };\n\n//     fetch(data_url, payload)\n//     .then(response => response.arrayBuffer())\n//     .then(data => {\n//         console.log(\"Processing tapped rhythms...\");\n//         // send a message back to the main thread if necessary\n//         self.postMessage({type: 'arrayProcessed', data: data});\n//     })\n//     .catch(error => {\n//         console.error(\"Error:\", error);\n//         self.postMessage({type: 'error', error: error});\n//     });\n// }\n\n\nfunction sendArrayToServer(array, bpm, temperatureValue, hitTolerance, isHttpConnected, httpIp, portInput, samplingStrategy) {\n    if (!isHttpConnected) return;\n\n    const data_url = `http://${httpIp}:${portInput}/send_array`;\n    console.log(\"Sending request to:\", data_url);\n\n    const payload = {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n            array: array,\n            bpm: bpm,\n            temp: temperatureValue,\n            thresh: hitTolerance,\n            samplingStrategy: samplingStrategy\n        })\n    };\n\n    fetch(data_url, payload)\n    .then(response => response.json())  // Process as JSON first\n    // checking the success field of the response, and if it's true, you're converting the data field (base64 encoded string of the MIDI binary) \n    // back to a byte array, and then you're posting this byte array back to the main thread:\n    .then(data => {\n        if (data.success) {\n            console.log(\"Processing tapped rhythms...\");\n            // const midiData = new Uint8Array(data.data);  // Convert base64 string to byte array\n            const base64decoded = atob(data.data);\n            const midiData = new Uint8Array(base64decoded.length).map((_, i) => base64decoded.charCodeAt(i));\n\n            console.log(\"Received MIDI data length:\", midiData.length);\n            self.postMessage({type: 'arrayProcessed', data: midiData});\n        } else {\n            console.warn(data.message);\n            self.postMessage({type: 'error', error: new Error(data.message)});\n        }\n    })    \n    .catch(error => {\n        console.error(\"Error:\", error);\n        self.postMessage({type: 'error', error: error});\n    });\n}\n"],"names":["self","addEventListener","event","data","cmd","$027baa645b81ae5d$var$sendArrayToServer","array","bpm","temperatureValue","hitTolerance","isHttpConnected","httpIp","portInput","samplingStrategy","data_url","console","log","payload","method","headers","body","JSON","stringify","temp","thresh","fetch","then","response","json","success","base64decoded","atob","midiData","Uint8Array","length","map","_","i","charCodeAt","postMessage","type","warn","message","error","Error","catch"],"version":3,"file":"workerAjax.6b1dfd8f.js.map"}